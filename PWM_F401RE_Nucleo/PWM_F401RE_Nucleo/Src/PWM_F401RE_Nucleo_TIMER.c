/*
 * File: PWM_F401RE_Nucleo_TIMER.c
 *
 * Generated by TIMER Coder for Xcos with scilab-5.5.2
 * C/C++ source code generated on  :05-Oct-2020
 *
 * Model version      :1.0
 *
 * ******************************************************************************
 * * attention
 * *
 * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
 * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
 * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
 * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
 * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
 * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
 * *
 * ******************************************************************************
 */
#include "PWM_F401RE_Nucleo.h"
#include "PWM_F401RE_Nucleo_TIMER.h"
extern void** PWM_F401RE_Nucleo_block_outtbptr; //External array definition of output pointers for blocks 

#include "PWM_F401RE_Nucleo_it.h"
TIM_DataLinkTypeDef*   G_TIM_Data;      /* Pointer to TIMER data information*/
TIM_HandleTypeDef*     G_TIM_Handler;   /* Pointer to TIMER handler */
/* TIM4 data information*/
TIM_DataLinkTypeDef   TIM4_DataLink;
/*******************************************************************************
* Function Name  : HAL_TIM_PeriodElapsedCallback
* Description    : Timer callback for update event
* Input          : TIM_HandleTypeDef*   TIM IC handle
*******************************************************************************/
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    TIM_DataLinkTypeDef*   pL_TIM_Data = G_TIM_Data; /* Pt to TIM data information */
    TIM_HandleTypeDef*     pL_TIM_Handler = G_TIM_Handler; /* Pt to TIM handler */
    if(pL_TIM_Handler == htim) {
        if(pL_TIM_Data->ItUpFcn != NULL){
            /* Call update function for TIM4 */
            pL_TIM_Data->ItUpFcn();
        }
    }
}
/*******************************************************************************
* Function Name  : HAL_TIM_PWM_PulseFinishedCallback
* Description    : Timer callback for OC or PWM
* Input          : TIM_HandleTypeDef*
*******************************************************************************/
void HAL_TIM_PWM_PulseFinishedCallback(TIM_HandleTypeDef *htim)
{
    TIM_DataLinkTypeDef*   pL_TIM_Data = G_TIM_Data; /* Pt to TIM data information */
    TIM_HandleTypeDef*     pL_TIM_Handler = G_TIM_Handler; /* Pt to TIM handler */
    if(pL_TIM_Handler == htim) {
        if(pL_TIM_Data->ItCcFcn != NULL){
            /* Call compare capture function for TIM4 */
            pL_TIM_Data->ItCcFcn(htim);
        }
    }
}

void TIMER_Initialize(void){
   /*Store TIM4 data information and its handler */
   G_TIM_Data = &TIM4_DataLink;
   G_TIM_Handler = &htim4;
   /*Store TIM information */
   TIM4_DataLink.TIM_Prescaler = 31249;
   TIM4_DataLink.TIM_APBClock = 12500000;
   TIM4_DataLink.TIM_ARR = 400 - 1;
   TIM4_DataLink.TIM_Clock = 400;
   TIM4_DataLink.CH2_duty = 0.33;
   TIM4_DataLink.CH3_duty = 0.66;
   TIM4_DataLink.CH2_type = OUTPUT_PWM;
   TIM4_DataLink.CH3_type = OUTPUT_PWM;
   /* Interrupt vector initialization */
   TIM4_DataLink.ItUpFcn = NULL;
   TIM4_DataLink.ItTrgFcn = NULL;
   TIM4_DataLink.ItComFcn = NULL;
   TIM4_DataLink.ItBrkFcn = NULL;
   TIM4_DataLink.ItCcFcn = NULL;
   /* Auto-reload preload enable */
   SET_BIT((&htim4)->Instance->CR1, TIM_CR1_ARPE);
   /*Update register value with blocset value*/
   /*Prescaler*/
   __HAL_TIM_SET_PRESCALER(&htim4, TIM4_DataLink.TIM_Prescaler);
   /*Autoreload: ARR */
   __HAL_TIM_SetAutoreload(&htim4, 400 - 1);
   /*Set CH2 Pulse value*/
   __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, (uint32_t)(132));
   /*Set CH3 Pulse value*/
   __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_3, (uint32_t)(264));
   /* Wait for htim4 State READY */
   while((&htim4)->State == HAL_TIM_STATE_BUSY) {}
   HAL_TIM_PWM_Start_IT(&htim4, TIM_CHANNEL_2);
   /* Enable the complementary PWM output 2 */
   HAL_TIMEx_PWMN_Start_IT(&htim4, TIM_CHANNEL_2);
   /* Wait for htim4 State READY */
   while((&htim4)->State == HAL_TIM_STATE_BUSY) {}
   HAL_TIM_PWM_Start_IT(&htim4, TIM_CHANNEL_3);
   /* Enable the complementary PWM output 3 */
   HAL_TIMEx_PWMN_Start_IT(&htim4, TIM_CHANNEL_3);
   /* Update interrupt function */
   TIM4_DataLink.ItUpFcn = TIM4_ItUpFcn;
   /* Capture/Compare interrupt function */
   TIM4_DataLink.ItCcFcn = TIM4_ItCcFcn;
   /* Start interrupt for Update event*/
   HAL_TIM_Base_Start_IT(&htim4);
}

