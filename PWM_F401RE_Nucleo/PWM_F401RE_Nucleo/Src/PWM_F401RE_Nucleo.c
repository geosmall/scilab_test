/*
 * File: PWM_F401RE_Nucleo.c
 *
 * Generated by STM32 Coder for Xcos with scilab-5.5.2
 * C/C++ source code generated on  :05-Oct-2020
 *
 * Model version      : 1.0
 *
 * ******************************************************************************
 * * attention
 * *
 * * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
 * * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
 * * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
 * * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
 * * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
 * * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
 * *
 * ******************************************************************************
 */

/* ---- Headers ---- */
#include <string.h> // memcpy
#include "STM32_Config.h"

#include "scicos_block4.h"

#include "PWM_F401RE_Nucleo.h"

double get_scicos_time(void);
void set_scicos_time(double t);
int get_phase_simulation(void);
void assert_sci_failed(const char* e, const char* file, int line){}

 
#define max(a,b) ((a) >= (b) ? (a) : (b))
#define min(a,b) ((a) <= (b) ? (a) : (b))
 
/* Table of constant values passed by ref */
static const int nrd_0 = 0;
static const int nrd_1 = 1;
static const int nrd_2 = 2;
static const int nrd_10 = 10;
static const int nrd_11 = 11;
static const int nrd_81 = 81;
static const int nrd_82 = 82;
static const int nrd_84 = 84;
static const int nrd_811 = 811;
static const int nrd_812 = 812;
static const int nrd_814 = 814;

/* Some general static variables passed by ref */
static int aaa=0, bbb=0;

/* data shared ptr declaration */
void **work;
void **PWM_F401RE_Nucleo_block_outtbptr;
scicos_block block_PWM_F401RE_Nucleo;
/* Dumy variable not used in embedded word but necessary for current version based on PC scicos C functions */
int local_flag=4; //Set to initialization
double t; //Simulation time (not used)

double sci_time;

const int size_SCSREAL_N_1x1[] = {1, 1, SCSREAL_N};

/* def real parameters */
const double RPAR1[ ] = {
/*
 * Routine name of block: evtdly4
 * UID of block: -1fde27db:15af159d27d:-7f9b
 * Compiled structure index: 3
 */
2.0000000000000001000000000E-01,0.0000000000000000000000000E+00,

};

const int IPAR1[1] = {0};
/* def object parameters */

/* Initial values */

/* Note that z[]=[z_initial_condition;outtbptr;work]
    z_initial_condition={};
    outtbptr={0};
    work= {0,0,0,0};
  */

   double z[]={0,0,0,0,0};

  int evoutptr[2];
  void* inptr[1];
  int inszptr[3*1];

  void* outptr[1];
  int outszptr[3*1];


  /* outtb declaration */
  long outtb_1[1]={0};

/*----------------------------------------  Initialization function */
int PWM_F401RE_Nucleo_Initialize()
{
  int nevprt=1;
  int nport;


  /* Get work ptr of blocks */
  work = (void **)(z+1);

  /* Get outtbptr ptr of blocks */
  PWM_F401RE_Nucleo_block_outtbptr = (void **)(z+0);

  PWM_F401RE_Nucleo_block_outtbptr[0] = (void *) outtb_1;

  /* Initialization */

  //Call TIMER Initialization function defined in _TIMER.c file
  TIMER_Initialize();

  /* Call of 'compteur' (type 2004 - blk nb 2 - uid ) */
  { 
    /* set blk struc. of 'compteur' (type 2004 - blk nb 2 - uid ) */
    block_PWM_F401RE_Nucleo.type   = 2004;
    block_PWM_F401RE_Nucleo.ztyp   = 0;
    block_PWM_F401RE_Nucleo.ng     = 0;
    block_PWM_F401RE_Nucleo.nz     = 0;
    block_PWM_F401RE_Nucleo.noz    = 0;
    block_PWM_F401RE_Nucleo.nrpar  = 0;
    block_PWM_F401RE_Nucleo.nopar  = 0;
    block_PWM_F401RE_Nucleo.nipar  = 0;
    block_PWM_F401RE_Nucleo.nin    = 0;
    block_PWM_F401RE_Nucleo.nout   = 1;
    block_PWM_F401RE_Nucleo.nevout = 0;
    block_PWM_F401RE_Nucleo.nmode  = 0;
    block_PWM_F401RE_Nucleo.evout = NULL;
    block_PWM_F401RE_Nucleo.inptr  = inptr;
    block_PWM_F401RE_Nucleo.insz = NULL;
    block_PWM_F401RE_Nucleo.outptr = outptr;
    block_PWM_F401RE_Nucleo.outptr[0] = PWM_F401RE_Nucleo_block_outtbptr[0];
    block_PWM_F401RE_Nucleo.outsz = outszptr;
    block_PWM_F401RE_Nucleo.outsz[0]  = 1;
    block_PWM_F401RE_Nucleo.outsz[1]  = 1;
    block_PWM_F401RE_Nucleo.outsz[2]  = SCSINT32_N;
    block_PWM_F401RE_Nucleo.z = &(z[0]);
    block_PWM_F401RE_Nucleo.work = (void **)(((double *)work)+1);
  }
  compteur(&block_PWM_F401RE_Nucleo,4);

    /* Dumy variable not used in embedded word but necessary for current version based on PC scicos C functions*/
    /* local_flag set to output update */
    local_flag = 1;
    double t; //Simulation time (not used)
return(1);
} //End of function PWM_F401RE_Nucleo_Initialize()
/*------------------------------  Step1 function called every 1 solver loop(s)*/
void PWM_F401RE_Nucleo_Step1()
{
  // double t;
  int nevprt=1;
  // int local_flag = 1; //Output update
  int nport;

/*---------------continuous activation state */
/*---------------STM32 block(s) without activation state  */
/*---------------STM32 solver step: NoEvt NoIn NoOut*/
/*---------------STM32 solver step: NoEvt NoIn Out*/
/*---------------STM32 solver step: NoEvt In Out*/
/*---------------STM32 solver step: NoEvt In NoOut*/
/*---------------FLAG: 1  */
    /* Output computation */
    if(*(uint32_t*)PWM_F401RE_Nucleo_block_outtbptr[0] !=  TIM4_DataLink.CH2_duty) {
      TIM4_DataLink.CH2_duty = *(uint32_t*)PWM_F401RE_Nucleo_block_outtbptr[0];
      if(*(uint32_t*)PWM_F401RE_Nucleo_block_outtbptr[0] >= 0) {
        // Channel0 duty cycle is an input port
        __HAL_TIM_SetCompare(&htim4, TIM_CHANNEL_2, (uint32_t)(*(uint32_t*)PWM_F401RE_Nucleo_block_outtbptr[0] * (&htim4)->Instance->ARR / 100));
      }
    }

    /* Call of 'compteur' (type 2004 - blk nb 2 - uid ) */
    { 
      /* set blk struc. of 'compteur' (type 2004 - blk nb 2 - uid ) */
      block_PWM_F401RE_Nucleo.type   = 2004;
      block_PWM_F401RE_Nucleo.ztyp   = 0;
      block_PWM_F401RE_Nucleo.ng     = 0;
      block_PWM_F401RE_Nucleo.nz     = 0;
      block_PWM_F401RE_Nucleo.noz    = 0;
      block_PWM_F401RE_Nucleo.nrpar  = 0;
      block_PWM_F401RE_Nucleo.nopar  = 0;
      block_PWM_F401RE_Nucleo.nipar  = 0;
      block_PWM_F401RE_Nucleo.nin    = 0;
      block_PWM_F401RE_Nucleo.nout   = 1;
      block_PWM_F401RE_Nucleo.nevout = 0;
      block_PWM_F401RE_Nucleo.nmode  = 0;
      block_PWM_F401RE_Nucleo.evout = NULL;
      block_PWM_F401RE_Nucleo.inptr  = inptr;
      block_PWM_F401RE_Nucleo.insz = NULL;
      block_PWM_F401RE_Nucleo.outptr = outptr;
      block_PWM_F401RE_Nucleo.outptr[0] = PWM_F401RE_Nucleo_block_outtbptr[0];
      block_PWM_F401RE_Nucleo.outsz = outszptr;
      block_PWM_F401RE_Nucleo.outsz[0]  = 1;
      block_PWM_F401RE_Nucleo.outsz[1]  = 1;
      block_PWM_F401RE_Nucleo.outsz[2]  = SCSINT32_N;
      block_PWM_F401RE_Nucleo.z = &(z[0]);
      block_PWM_F401RE_Nucleo.work = (void **)(((double *)work)+1);
    }
    compteur(&block_PWM_F401RE_Nucleo,1);
    compteur(&block_PWM_F401RE_Nucleo,2);


  } //End of PWM_F401RE_Nucleo_Step1 function


double get_scicos_time()
{
  return sci_time;
}

void set_scicos_time(double t)
{
 sci_time = t;
}

int get_phase_simulation()
{
  return 1;
}



void set_block_error(int err)
{
  return;
}

void * scicos_malloc(size_t size)
{
  return malloc(size);
}

void scicos_free(void *p)
{
  free(p);
}

void do_cold_restart()
{
  return;
}

void sciprint (char *fmt)
{
  return;
}

